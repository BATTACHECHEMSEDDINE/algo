<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tree Visualizer</title>
<style>
  body {
    font-family: "Segoe UI", sans-serif;
    background: #f2f2f2;
    text-align: center;
    margin: 0;
    padding: 0;
  }

  header {
    background: #333;
    color: white;
    padding: 15px;
    font-size: 1.5em;
    letter-spacing: 1px;
  }

  .controls {
    margin: 20px;
  }

  input {
    padding: 8px;
    width: 120px;
    font-size: 1em;
  }

  button {
    margin: 5px;
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    background: #444;
    color: white;
    cursor: pointer;
    transition: 0.2s;
  }

  button:hover {
    background: #666;
  }

  .tree-selector {
    margin-bottom: 15px;
  }

  .tree-selector button.active {
    background: #2196f3;
  }

  canvas {
    border: 1px solid #aaa;
    background: white;
    display: block;
    margin: 0 auto 40px;
  }
</style>
</head>
<body>

<header>ðŸŒ³ Tree Visualizer</header>

<div class="controls">
  <div class="tree-selector">
    <button data-tree="BST" class="active">Binary Search Tree</button>
    <button data-tree="AVL">AVL Tree</button>
    <button data-tree="Heap">Heap</button>
  </div>

  <input id="valueInput" type="number" placeholder="Enter value" />
  <button id="insertBtn">Insert</button>
  <button id="deleteBtn">Delete</button>
  <button id="clearBtn">Clear</button>
</div>

<canvas id="treeCanvas" width="800" height="500"></canvas>

<script>

class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class Tree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (!this.root) {
      this.root = newNode;
      return;
    }

    let current = this.root;
    while (true) {
      if (value === current.value) return; // skip duplicates
      if (value < current.value) {
        if (!current.left) {
          current.left = newNode;
          return;
        }
        current = current.left;
      } else {
        if (!current.right) {
          current.right = newNode;
          return;
        }
        current = current.right;
      }
    }
  }

  delete(value, node = this.root) {
    if (!node) return null;

    if (value < node.value) node.left = this.delete(value, node.left);
    else if (value > node.value) node.right = this.delete(value, node.right);
    else {
      // found the node
      if (!node.left) return node.right;
      if (!node.right) return node.left;
      let minNode = this.findMin(node.right);
      node.value = minNode.value;
      node.right = this.delete(minNode.value, node.right);
    }
    return node;
  }

  findMin(node) {
    while (node.left) node = node.left;
    return node;
  }

  clear() {
    this.root = null;
  }
}


class AVLTree extends Tree {}
class HeapTree extends Tree {}


const canvas = document.getElementById("treeCanvas");
const ctx = canvas.getContext("2d");

const trees = {
  BST: new Tree(),
  AVL: new AVLTree(),
  Heap: new HeapTree(),
};

let currentType = "BST";
let currentTree = trees[currentType];


document.querySelectorAll(".tree-selector button").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".tree-selector button").forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    currentType = btn.dataset.tree;
    currentTree = trees[currentType];
    drawTree();
  });
});


document.getElementById("insertBtn").addEventListener("click", () => {
  const val = parseInt(document.getElementById("valueInput").value);
  if (!isNaN(val)) {
    currentTree.insert(val);
    drawTree();
  }
});


document.getElementById("deleteBtn").addEventListener("click", () => {
  const val = parseInt(document.getElementById("valueInput").value);
  if (!isNaN(val)) {
    currentTree.root = currentTree.delete(val);
    drawTree();
  }
});


document.getElementById("clearBtn").addEventListener("click", () => {
  currentTree.clear();
  drawTree();
});


function drawTree() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (currentTree.root) {
    drawNode(currentTree.root, canvas.width / 2, 60, canvas.width / 4);
  }
}

function drawNode(node, x, y, offset) {
  if (!node) return;

  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.fillStyle = "#000";
  ctx.font = "16px Arial";
  ctx.fillText(node.value, x - 6, y + 5);

  if (node.left) {
    ctx.beginPath();
    ctx.moveTo(x, y + 20);
    ctx.lineTo(x - offset, y + 80 - 20);
    ctx.stroke();
    drawNode(node.left, x - offset, y + 80, offset / 2);
  }

  if (node.right) {
    ctx.beginPath();
    ctx.moveTo(x, y + 20);
    ctx.lineTo(x + offset, y + 80 - 20);
    ctx.stroke();
    drawNode(node.right, x + offset, y + 80, offset / 2);
  }
}
</script>
</body>
</html>
